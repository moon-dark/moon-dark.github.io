---
title: 动态规划经典——石子归并
date: 2018-01-12 10:25:46
tags:
  - code
  - algorithm
---
# 动态规划 (Dynamic Programming, 简称DP)
[动态规划：从新手到专家](http://www.hawstein.com/posts/dp-novice-to-advanced.html) <br>
[Dynamic Programming: From novice to advanced ](http://community.topcoder.com/tc?module=Static&d1=tutorials&d2=dynProg) <br>
动态规划算法通常基于一个递推公式及一个或多个初始状态。 当前子问题的解将由上一次子问题的解推出。使用动态规划来解题只需要多项式时间复杂度， 因此它比回溯法、暴力法等要快许多。


### 问题描述
N堆石子摆成一条线。现要将石子有次序地合并成一堆。规定每次只能选相邻的2堆石子合并成新的一堆，并将新的一堆石子数记为该次合并的代价。计算将N堆石子合并成一堆的最小代价。
```
例如： 1 2 3 4，有不少合并方法
1 2 3 4 => 3 3 4(3) => 6 4(9) => 10(19)
1 2 3 4 => 1 5 4(5) => 1 9(14) => 10(24)
1 2 3 4 => 1 2 7(7) => 3 7(10) => 10(20)
```
<!-- more -->
**【输入格式】**  <br>
第1行：N（2 <= N <= 50000)  <br>
第2 - N + 1：N堆石子的数量（1 <= A[i] <= 10000）  <br>

**【输出格式】**
输出最小合并代价

**【输入样例】**
7
13
7
8
16
21
4
18

**【输出样例】**
239

**【解析】**  <br>
令dp[i,j]表示归并第i个数到第j数的最小代价,
sum[i,j]表示第i个数到第j个数的和，这个可以事先计算出来。sum[i,j]可以在O(1)的时间内算出.

- 当n=1时，dp[1][1] = 0;
- 当n=2时，dp[1][2] = a[1]+a[2];
- 当n=3时，dp[1][3] = min(dp[1][1] + dp[2][3], dp[1][2] + dp[3][3]) + sum[3];


<font color=#DC143C size=5>
dp[i][j] = 0    i = j  <br>
dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j] + sum[j] - sum[i-1])   i ≠ j  <br>
</font>

**【代码】**
```cpp
#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;

#define INF 100000000
int solveMeFirst(int* A, int N) {
   int f[N][N],sum[N][N];
   int i, j, k;
   for(i=0; i<N; i++) {
       f[i][i] = 0;
       sum[i][i] = A[i];
       for(j=i+1;j<N;j++) {
           sum[i][j] = sum[i][j-1] + A[j];
       }
   }

   for(int len=2;len<=N;len++) {  //归并的石子长度
      for(i=0;i<N-len+1;i++) {
         j=i+len-1;
         f[i][j]=INF;
         for(k=i;k<j;k++) {     //i为起点, j为终点
            f[i][j] = std::min(f[i][j], f[i][k]+f[k+1][j]+sum[i][j]);
         }
      }
   }

   return f[0][N-1];
}

int main() {
  int K, N;
  scanf("%d",&N);
  int* A = new int[N];
  for(int i=0; i<N;i++)
      scanf("%d",&A[i]);

  printf("%d\n",solveMeFirst(A, N));
  return 0;
}

```
